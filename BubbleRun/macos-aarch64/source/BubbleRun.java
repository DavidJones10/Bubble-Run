/* autogenerated by Processing revision 1293 on 2023-09-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import com.pdplusplus.*;
import com.portaudio.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class BubbleRun extends PApplet {



Pd pd;
MyMusic music;

ArrayList<Bubble> bubbles = new ArrayList<Bubble>();
PVector character;
PVector coreVelo = new PVector(0,0);
PVector coreAccel = new PVector(0,0);
int coreSize = 50;

int scale[] = {0, 2, 3, 5, 7, 9, 10, 12, 14, 15, 17, 19, 21, 22, 24};
int transposition = 60;

float timeFloat = 0;
int seconds = 0;

Timer timer = new Timer(5, 595);

boolean gameLost = false;
int screen = 0; // Screen 0: loading screen; Screen 1: game; Screen 2: lost screen

int newBubbleX = 0;
int newBubbleY = 0;
boolean addBubb = false;
Menu menu;

String localName = new String();

int numKeys = 0;

LeaderBoard boards[] = new LeaderBoard[3];
String modeNames[] = new String[3];

Button toMenu;
Button playAgain;

int mode=0;
boolean nameEntered = false;
int bubblesToAdd;

//============================================================
public void setup()
{
  /* size commented out by preprocessor */;
  background(0);
  bubbles.clear();
  frameRate(60);
  localName = "";
  bubblesToAdd = 1;

  character = new PVector(width/2, height/2);
  for (int i=0; i < 3; i++)
  {
     bubbles.add(new Bubble(random(width), random(0,100)));
  }
  for (int i=0; i < boards.length; i++)
  {
    boards[i] = new LeaderBoard();
    modeNames[i] = new String();
  }
  modeNames[0] = "Standard";
  modeNames[1] = "Gravity";
  modeNames[2] = "Chase";

  menu = new Menu();
  music = new MyMusic();
  toMenu = new Button();
  playAgain = new Button();
  String path = this.dataPath("Game_Music_AvoidIO.wav");
  music.readFile(path);

  pd = Pd.getInstance(music);
  pd.start();
  menu.reset();
  gameLost = false;
}
//============================================================
public void draw()
{
  background(50);
  seconds = timer.currentTime();
  timeFloat = timer.currentTimeFloat();
//========================= Before game screen
  if (screen == 0)
    {
      timer.reset();
      menu.show();
    }
//========================= During game screen
  else if (screen == 1)
  {
   timer.DisplayTime();
   if (mode == 0 || mode == 2)
   {
    if (seconds !=0 && seconds % 2 == 0)
     {
       if (!addBubb)
         bubbles.add(new Bubble(newBubbleX, newBubbleY));
       for (int i=0; i < bubbles.size(); i++)
        {bubbles.get(i).mag += .002f;}
       addBubb = true;
     }
     else
       {addBubb=false;}
   }
   else
   {
    if (frameCount % 120 == 0)
      {
        if (!addBubb)
        {
          for (int i=0; i < (int)(seconds/2); i++)
            {bubbles.add(new Bubble((int)random(width), -20));}
          addBubb = true;
        }
        else
          addBubb = false;
      }
   }
   if (mode == 2)
   {
    float characterFreq = map(character.y, height, 0, 0, 2000);
    music.setFreqSin(characterFreq);
   }
   for (int i=0; i < bubbles.size(); i++)
   {
     bubbles.get(i).show();
     bubbles.get(i).update(mode);
   }
   collisions();
  }
  //========================= After game screen
  else
  {
    
    boards[mode].setLocation(250, 20);
    boards[mode].scaleBoard(1.9f);
    boards[mode].setModeName(modeNames[mode]);
    boards[mode].show();
    toMenu.drawButton();
    playAgain.drawButton();
    if (boards[0].nameNecessary(timeFloat) && !nameEntered)
    {
      textSize(30);
      fill(255, 255, 255);
      textAlign(CENTER);
      text("INSERT 4 LETTER NAME BELOW:", 20, 40, 200, 200);
      textAlign(LEFT);
      textSize(50);
      text(localName, 20, 140, 200, 100);
    }
    afterLossLogic();
    timer.DisplayTime();
  }
}
//============================================================
public void dispose()
{
  pd.stop();
  println("Print this when sketch is stopped.");
  super.dispose();
}
//============================================================
public void collisions()
{  
  character.add(coreVelo);

  FloatList distances = new FloatList();

  //float d  = character.dist(bubbles[0].pos);
  for (int i=0; i < bubbles.size(); i++)
    {
      distances.append(character.dist(bubbles.get(i).pos));
      if (distances.get(i) < bubbles.get(i).rad+coreSize/2)
        {
          music.triggerAtkSaw();
          music.triggerRelSin();
          timer.pause();
          screen = 2;
          nameEntered = false;
        }
      if (bubbles.get(i).pos.y > height)
        {bubbles.remove(i);}
    }
  fill(255,255,255,200);
  ellipse(character.x, character.y, coreSize,coreSize);
  fill(0,0,0,200);
  ellipse(character.x, character.y, coreSize/2,coreSize/2);
  update();
  newBubblePos();
}
//============================================================
public void update()
{
  if (character.x < coreSize)
    {character.x = coreSize;}
  else if (character.x > width - coreSize)
    {character.x = width - coreSize;}
  if (character.y < coreSize)
    {character.y = coreSize+2;}
  else if (character.y > height - coreSize)
    {character.y = height - coreSize;}
}
//============================================================
public void newBubblePos()
{
  if (character.x > 500)
    newBubbleX = (int)character.x - 400;
  else if (character.x < 500)
    newBubbleX = (int)character.x + 400;
  if (character.y > 300)
    newBubbleY = (int)character.y - 200;
  else if (character.y < 300)
    newBubbleY = (int)character.y + 200;
}
//============================================================
public void keyPressed()
{
  if (screen == 1)
    {
      if (keyPressed && key == 'a')
        {coreVelo.x = -5;}
      if (keyPressed && key == 'd')
        {coreVelo.x = 5;}

      if (keyPressed && key == 'w')
        {coreVelo.y = -5;}
      if (keyPressed && key == 's')
        {coreVelo.y = 5;}
  }
  else if (screen == 2)
  {
    if (boards[mode].nameNecessary(timeFloat) && !nameEntered)
    {
      numKeys++;
      if (numKeys < 5)
      {
        localName += key;
      }
      if (localName.length() == 4)
      {
        boards[mode].setTextAndScore(localName, timeFloat);
        numKeys = 0;
        localName = "";
        nameEntered = true;
      }
    }
  }
}
//============================================================
public void keyReleased()
{
  if (screen == 1)
  {
    if (key == 'a' || key == 'd')
      {coreVelo.x = 0;}
    if (key == 'w' || key == 's')
      {coreVelo.y = 0;}

  }

}
//============================================================
public void afterLossLogic()
{
  toMenu.setSizeAndLocation(730,20,250,150,12);
  toMenu.setText("Return To Menu", 37);
  toMenu.setColors(65,124,105,255,255,255);
  playAgain.setSizeAndLocation(730,190,250,150,12);
  playAgain.setText("Play Again", 40);
  playAgain.setColors(80,104,88,255,255,255);
  if (toMenu.Pressed())
    if (nameEntered)
    {
      music.resetWav();
      screen = 0;
    }
    else
      text("PLEASE ENTER A NAME", 500, 555);
  else if (playAgain.Pressed())
    {
        if (nameEntered || !boards[mode].nameNecessary(timeFloat))
          {
            screen = 1; 
            if (mode == 2)
              music.triggerAtkSin();
            resetMode(mode);
          }
        else
          text("PLEASE ENTER A NAME", 500, 555);
    }
    
}
//============================================================
public void resetMode(int Mode)
{
  screen = 1;
  bubblesToAdd = 1;
  coreVelo.x = coreVelo.y = 0;
  timer.restart();
  bubbles.clear();
  character.set(width/2, height/2);
  if (mode == 0 || mode ==2)
  {
    for (int i=0; i < 3; i++)
      {bubbles.add(new Bubble(random(width), random(0,100)));}
  }
  else
  {
    for (int i=0; i < 3; i++)
      {bubbles.add(new Bubble(random(width), -20));}
  }
}
class Bubble
{
  PVector pos;
  int c;
  float rad;
  PVector velo;
  PVector accel;
  PVector gravity;
  float topSpeed;
  String text ="";
  boolean ceilOrFloor = false;
  boolean collDetected = false;
  float mag = .02f;
  
  Bubble (float x, float y)
  {
    this.c = color(random(255), random(255), random(255), 200);
    this.pos = new PVector(x,y);
    if (mode==2)
      this.velo = new PVector(random(1), 0);
    else 
      this.velo = new PVector(random(-4, 4), random(4));

    this.rad = random(20,50);
    topSpeed = 2;
    mag = .02f;
    
  }
  public void setText(String txt)
  {
    text = txt;
  }
  public void show()
  {
    noStroke();
    fill(c);
    ellipse(pos.x, pos.y, rad*2, rad*2);
    fill(0,0,0,200);
    textSize(20);
    text(text, pos.x, pos.y);
  }
  public void update(int mode_)
  {
    switch (mode_)
    {
      case 0:
        mode0update();
        break;
      case 1:
        mode1update();
        break;
      case 2:
        mode2update();
        break;
    }
  }
    //pos.add(PVector.random2D().mult(4));
  public void randomColor() 
  {
    c = color(random(255), random(255), random(255), 200);
  } 
  public void mode0update()
  {
    collDetected = false;
    if (pos.x < rad)
      {
        pos.x = rad;
        velo.x *= -1;
        collDetected = true;
        ceilOrFloor = false;
      }
      else if (pos.x > width - rad)
      {
        pos.x = width - rad;
        velo.x *= -1;
        collDetected = true;
        ceilOrFloor = false;
      }
      if (pos.y < rad)
      {
        pos.y = rad;
        velo.y *= -1;
        collDetected = true;
        ceilOrFloor = true;
      }
      else if (pos.y > height - rad)
      {
        pos.y = height - rad;
        velo.y *= -1;
        collDetected = true;
        ceilOrFloor = true;
      }
      pos.add(velo);
      if (collDetected)
      {
        int note = 0;
        randomColor();
        if (!ceilOrFloor)
          note = scale[(int)map(pos.y, height, 0, 0, scale.length)] + transposition;
        else
          note = scale[(int)random(0,14)] + (transposition + 12*(int)random(-2,2));
        float freq = (float)pd.mtof(note);
        music.setPan(map(pos.x, 0, width, 0, 1));
        music.setFreq(freq);
        music.triggerAtk();
      }
  }

  public void mode1update()
  {
    collDetected = false;
    gravity = new PVector(0,0.01f);
    velo.add(gravity);
    pos.add(velo);
    if (pos.x < rad)
    {
      pos.x = rad;
      velo.x *= -1;
      collDetected = true;
      ceilOrFloor = false;
    }
    else if (pos.x > width - rad)
    {
      pos.x = width - rad;
      velo.x *= -1;
      collDetected = true;
      ceilOrFloor = false;
    }
    if (pos.y < rad)
    {
      collDetected = true;
      ceilOrFloor = true;
    }
    else if (pos.y > height - rad)
    {
      collDetected = true;
      ceilOrFloor = true;
    }
    pos.add(velo);
    if (collDetected)
    {
      int note = 0;
      randomColor();
      if (!ceilOrFloor)
        note = scale[(int)map(pos.y, height, 0, 0, scale.length)] + transposition;
      else
        note = scale[(int)random(0,14)] + (transposition + 12*(int)random(-2,2));
      float freq = (float)pd.mtof(note);
      music.setPan(map(pos.x, 0, width, 0, 1));
      music.setFreq(freq);
      music.triggerAtk();
      ceilOrFloor = false;
      collDetected = false;
    }

  }

  public void mode2update()
  {
    collDetected = false;
    PVector accel = PVector.sub(character,pos);
    accel.setMag(mag);
    velo.add(accel);
    velo.limit(topSpeed);
    pos.add(velo);

    if (pos.x < rad)
    {
      pos.x = rad;
      velo.x *= -.5f;
      collDetected = true;
      ceilOrFloor = false;
    }
    else if (pos.x > width - rad)
    {
      pos.x = width - rad;
      velo.x *= -.5f;
      collDetected = true;
      ceilOrFloor = false;
    }
    if (pos.y < rad)
    {
      pos.y = rad;
      velo.y *= -.5f;
      collDetected = true;
      ceilOrFloor = true;
    }
    else if (pos.y > height - rad)
    {
      pos.y = height - rad;
      velo.y *= -.5f;
      collDetected = true;
      ceilOrFloor = true;
    }
    pos.add(velo);
    if (collDetected)
    {
      int note = 0;
      randomColor();
      if (!ceilOrFloor)
        note = scale[(int)map(pos.y, height, 0, 0, scale.length)] + transposition;
      else
        note = scale[(int)random(0,14)] + (transposition + 12*(int)random(-2,2));
      float freq = (float)pd.mtof(note);
      music.setPan(map(pos.x, 0, width, 0, 1));
      music.setFreq(freq);
      music.triggerAtk();
    }
  }
}
//==============================================================
// Simple button Class
class Button
{
  int xLoc=0, yLoc=0, width_=0, height_=0, rounded = 0;
  int buttonColor = color(0,0,0);
  String buttonText = "";
  int textSize = 1;
  int textColor = color(255,255,255);
  
  public void setSizeAndLocation(int x, int y, int w, int h)
  {
    xLoc = x;
    yLoc = y;
    width_ = w;
    height_ = h;
  }
  public void setSizeAndLocation(int x, int y, int w, int h, int roundedness)
  {
    xLoc = x;
    yLoc = y;
    width_ = w;
    height_ = h;
    rounded = roundedness;
  }
  public void setColors(int r, int g, int b, int textR, int textG, int textB)
  {
    buttonColor = color(r,g,b);
    textColor = color(textR,textG,textB);
  }
  public void setText (String text, int size)
  {
    textSize = size;
    buttonText = text;
  }
  public void drawButton()
  {
    fill(buttonColor);
    rect(xLoc, yLoc, width_, height_, rounded);
    textSize(textSize);
    fill(textColor);
    int textHeight = (int)(textAscent() + textDescent());
    text(buttonText, xLoc + (width_ - textWidth(buttonText))/2, yLoc + (height_ + textHeight)/2);
  }
  public boolean Pressed()
  {
    if (mousePressed && mouseX >= xLoc && mouseX <= xLoc+width_ && mouseY >= yLoc 
          && mouseY <= yLoc+height_)
      {return true;}  
    else
      {return false;}
  }
}
class LeaderBoard
{
  FloatDict players;
  int maxNumPlayers = 5;
  int numPlayers = 0;
  int textPosStart = 50;
  int textX = 500;
  int textY = 10;
  int textJump = 35;
  String modeName = "";
  float scalar = 1.0f;

  LeaderBoard()
  {
      players = new FloatDict();
  }

  public void show()
  {
    //textJump = (int)((float)textJump * scalar);
    fill(96, 94, 96);
    rect(textX - 10, textY, (int)(scalar * 240), (int)(scalar * 250), 20);
    textSize(40*scalar);
    fill(0,0,0);
    text(modeName + ":", textX + (int)(30*scalar), textY + (int)(35*scalar));
    int inc = 1;
    players.sortValuesReverse();
    textSize(30*scalar);
    fill(255, 180, 200);
    for (String s : players.keys())
    {
      text(inc + ". " + s + ":   " + players.get(s), textX, (int)(textJump * scalar) * inc 
                                                              + (textY + (int)(45*scalar)));
      inc++;
    }
  }
  
  public void setTextAndScore(String text, float score)
  {
    players.set(text, score);
    players.sortValuesReverse();
    if (players.size() > 5)
      players.remove(players.minKey());
  }
  
  public boolean nameNecessary(float score)
  {
    if (players.size() < 5)
      return true;
    else
    {
      if (score > (float)players.get(players.minKey()))
        return true;
      else
        return false;
    }
  }
  public void setLocation(int x, int y)
  {
    textX = x;
    textY = y;
  }
  public void setModeName(String name)
  {
    modeName = name;
  }
  public void scaleBoard(float scale)
  {
    scalar = scale;
  }

}
class Menu
{
  int numOfModes= 3;
  Button buttons[] = new Button[numOfModes];

  Menu()
  {
    for (int i=0; i < numOfModes; i++)
      {buttons[i] = new Button();}
  }
  public void show()
  {
    background(129, 143, 142);
    fill(66, 80, 85);
    rect(20, 10, 420, 365, 12);
   
    fill(255,255,255);
    textSize(70);
    text("Modes", 140, 80);

    fill(26, 65, 50);
    rect(440+20, 10, 520, 585, 12);
    
    fill(255,255,255);
    textSize(70);
    text("Leaderboards", 520, 65);
    textSize(50);
    text("w: up", 10, 420);
    text("a: left", 200, 420);
    text("s: down", 10, 480);
    text("d: right", 200, 480);

    for (int i=0; i < buttons.length; i++)
    {
      buttons[i].setSizeAndLocation(30,(i*85)+100, 400, 85);
      buttons[i].setColors(50*i,15,50*i,500,200,500);
      buttons[i].setText(modeNames[i], 50);
      buttons[i].drawButton();
    }
    boards[0].setLocation(480, 80);
    boards[1].setLocation(740, 80);
    boards[2].setLocation(610, 340);
    for (int i=0; i < modeNames.length; i++)
    {
      boards[i].scaleBoard(1);
      boards[i].setModeName(modeNames[i]);
      boards[i].show();
    }
    timer.DisplayTime();
    checkPressed();
  }
  public int getMode()
    {return mode;}
  
  public void reset()
    {
      mode = -1;
    }
  public void checkPressed()
  {
    if (buttons[0].Pressed())
    {
      mode = 0;
      resetMode(mode);
    }
    else if (buttons[1].Pressed())
    {
      mode = 1;
      resetMode(mode);
    }
    else if (buttons[2].Pressed())
    {
      mode = 2;
      music.triggerAtkSin();
      resetMode(mode);
    }
  }
  
}
class Reverb {

VariableDelay delay1 = new VariableDelay();
VariableDelay delay2 = new VariableDelay();
VariableDelay delay3 = new VariableDelay();
VariableDelay delay4 = new VariableDelay();
VariableDelay delay5 = new VariableDelay();
VariableDelay delay6 = new VariableDelay();
LowPass lop = new LowPass();

double gain1 = .7f;
double gain2 = 0.68f;
double gain3 = .80f;
double gain4 = .58f;
double gain5 = .77f;
double gain6 = .79f;

double del1 = 0;
double del2 = 0;
double del3 = 0;
double del4 = 0;
double allpass1 = 0;
double allpass2 = 0;
//Our interface to the reverberator
double volume = 0; //0-100
double crossover = 15000; //0-100

double out = 0;

//keep this consistent with other Pd++ classes
public double perform(double input) {
    delay1.delayWrite(del1 * gain1);//feedback
    del1 =  delay1.perform(104) + input;
    delay2.delayWrite(del2 * gain2);
    del2 =  delay2.perform(400) + input;
    delay3.delayWrite(del3 * gain3);
    del3 =  delay3.perform(700) + input;
    delay4.delayWrite(del4 * gain4);
    del4 =  delay2.perform(3000) + input;
    
  
  double combs = (del1 + del2 + del3 + del4) * .5f;//Summing step. Because we have four combs, we divide by four, or * .25
  
  //Allpass filter series
  delay5.delayWrite(allpass1 * gain5);
  allpass1 = delay5.perform(23) + combs; 
  allpass1 *= 1 - (gain5*gain5); //1-g^2
  allpass1 += (gain5*-1) * combs; //-g
  
  delay6.delayWrite(allpass2 * gain6);
  allpass2 = delay6.perform(7.6f) + allpass1;
  allpass2 *= 1 - (gain6*gain6);
  allpass2 += (gain6*-1) * allpass1;
  
  out = allpass1 + allpass2;
  
  //Add a simple low pass for a damping effect
  lop.setCutoff(getCrossover());
 
return lop.perform(out);

}

public void setTime() {
    
}

public void setVolume(double v) {
 
  volume = v;
 
}

public double getVolume() {
  return volume;
}   

public void setCrossover(double c) {
  
  crossover = c;
}

public double getCrossover() {
 return crossover; 
}

public void free() {
  VariableDelay.free(delay1);
  VariableDelay.free(delay2);
  VariableDelay.free(delay3);
  VariableDelay.free(delay4);
  VariableDelay.free(delay5);
  VariableDelay.free(delay6);
  LowPass.free(lop);
  }

}
class MyMusic extends PdAlgorithm 
{
  int voices = 12;
  Synth synths[] = new Synth[voices];
  Line line = new Line();
  Phasor saw = new Phasor();
  Oscillator sine = new Oscillator();
  Reverb rev = new Reverb();
  Line sineLine = new Line();
  float oscFreq = 440;
  float amp = 1;
  double sawEnv = 0;
  double sineEnv = 0;
  double sawAmp = .2f;

  double envelopes[] = new double[12];
  boolean envBang = false;
  boolean bangs[] = new boolean[12];
  boolean isArray = false;
  float fundamental = 10;
  int interval = 1;
  int currentVoice = 0;
  SoundFiler wav = new SoundFiler();
  double[] soundFile;
  double fileSize;
  int counter = 0;
  double fileVolume = .1f;
  boolean sineBang = false;
  float sineFreq;
 
   
  public void readFile(String file) 
  {
    fileSize = wav.read(file);
    soundFile = wav.getArray();
  }
  public void resetWav()
  {
    counter = 0;
  }

  MyMusic()
  {
     for (int i=0; i < synths.length; i++)
      {synths[i] = new Synth();}
     rev.setVolume(100);
  }
  
  public void runAlgorithm(double in1, double in2)
  {
   if (screen == 1 || screen == 2)
   {
      if (envBang)
        sawEnv = line.perform(sawAmp,1);
      else 
        sawEnv = line.perform(0, 1000);
      if (sawEnv ==sawAmp)
        envBang = false;
      
      if (sineBang)
        sineEnv = sineLine.perform(.08f,1);
      else 
        sineEnv = sineLine.perform(0, 1000);

      double sawOut = saw.perform(500*sawEnv)*sawEnv;
      double sineOut = sine.perform(sineFreq)*sineEnv;
      double outL = 0;
      double outR = 0;
      for (int i = 0; i < voices; i++)
      {
        double out = synths[i].perform(amp);
        float panning = synths[i].getPan();
        outL += out * (1-panning) + sineOut;
        outR += out * panning + sineOut;
      }
       outL *= (1.0f/voices);
       outR *= (1.0f/voices);
       outputL = outL+sawOut+rev.perform(outL);
       outputR = outR+sawOut+rev.perform(outR);
    }
    else if (screen == 0)
    {
      if(counter != fileSize)
      {
          outputL = soundFile[counter++] * fileVolume;
          outputR = soundFile[counter++] * fileVolume;
          if(counter == fileSize) counter = 0;
      }
    }
  }
  
  public synchronized void setPan(float p)
  {
    synths[currentVoice].setPan(p);
  }

  public synchronized float getFreq ()
    {return oscFreq;}
  
  public synchronized void setFreq (float f1)
  {
    synths[currentVoice].setFreq(f1);
    fundamental = f1;
    notify();
  }
  
  public synchronized void setInterval(int inter)
    {interval = inter;}
  
  public synchronized float getAmp ()
    {return amp;}
  
  public synchronized void setAmp(float am)
    {amp = am;}
  
  public synchronized void triggerAtk()
    {
      synths[currentVoice].triggerAtk();
      currentVoice = (currentVoice +1) % voices;
    }
  
  public synchronized void useArray()
    {isArray = true;}
  
  public synchronized void triggerAtkSaw() 
  {
     envBang = true;
  }
  public synchronized void triggerAtkSin()
  {
    sineBang = true;
  }
  public synchronized void triggerRelSin()
  {
    sineBang = false;
  }
  public synchronized void setFreqSin(float freq)
  {
    sineFreq = freq;
  }
  
  public void free()
  {
    for (int i=0; i < synths.length; i++)
    {
      synths[i].free();
    }
    Oscillator.free(sine);
    Phasor.free(saw);
    SoundFiler.free(wav);
  }
}
class Synth 
{
  Oscillator osc;
  Line line;
  double env = 0;
  boolean envBang;
  double freq = 440;
  float pan = .5f;
  Synth() 
  {
    osc = new Oscillator();
    line = new Line();
  }
  public double perform(double amp)
  {
    double out = 0; 
    if (envBang) 
      {env = line.perform(amp, 5);} 
     else 
     {
       env = line.perform(0, 1000);
     }

    if (env == amp)
      envBang = false;
    out = osc.perform(getFreq())*env;
    return out;
  }
  public double getFreq()
    {return freq;}
  public void setFreq(float frequency)
    {freq = frequency;}
  public void triggerAtk()
    {envBang = true;}
  public void setPan(float p)
    {pan = p;}
  public float getPan()
    {return pan;}
  public void free()
  {
      Oscillator.free(osc);
      Line.free(line);
  }
    
  

}
class Timer
{
 long startTime ; // time in msecs that timer started
 long timeSoFar ; // use to hold total time of run so far, useful in
 // conjunction with pause and continueRunning
 boolean running ;
 int x, y ; // location of timer output

 Timer(int inX, int inY)
 {
 x = inX ;
 y = inY ;
 running = false ;
 timeSoFar = 0 ;
 }


 public int currentTime()
 {
    if ( running )
       return ( (int) ( (millis() - startTime) / 1000.0f) ) ;
    else
       return ( (int) (timeSoFar / 1000.0f) ) ;
 }

 public float currentTimeFloat()
 {
    if ( running )
       return ( ( (millis() - startTime) / 1000.0f) ) ;
    else
       return ( (timeSoFar / 1000.0f) ) ;
 }

 public void start()
 {
 running = true ;
 startTime = millis() ;
 }
 public void restart()
 // reset the timer to zero and restart, identical to start
 {
 start() ;
 }
 public void reset()
 {
    timeSoFar = 0;
 }

 public void pause()
 {
 if (running)
 {
  timeSoFar = millis() - startTime ;
  running = false ;
 }
 // else do nothing, pause already called
 }

 public void continueRunning()
 // called after stop to restart the timer running
 // no effect if already running
{
 if (!running)
 {
  startTime = millis() - timeSoFar ;
 running = true ;
 }
 }

 public void DisplayTime()
 {
  float theTime ;
  String output = "";
  int subtractor = 0;
  if (timeFloat < 10 && timeFloat > 0)
    subtractor = 33;
  else if (timeFloat ==0)
    subtractor = 99;

    

  theTime = currentTimeFloat();
  output = output + theTime;

 // println("output = " + output) ;
  strokeWeight(4);
  stroke(10);
  fill(96, 94, 96);
  rect(0,535,198-subtractor,70,0,24,0,0);
  noStroke();
  fill(500,200,500) ;
  textSize(70);
  text(output,x,y) ;
 }

}


  public void settings() { size(1000, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "BubbleRun" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
